/* global APP_TITLE */
import AudioEngine from './index';
import { OfflineAudioContext as StandardizedOfflineAudioContext } from 'standardized-audio-context';
import encodeWav from './encoders/wav';
import EncodeMp3Task from './encoders/mp3';
import eventEmitter from 'event-emitter';
import allOff from 'event-emitter/all-off';
// import normalizeSpaces from '../util/normalizeSpaces';

const OfflineAudioContext = window.OfflineAudioContext || StandardizedOfflineAudioContext;

// todo: move to constants?
// todo: adjust for number of output channels
const EXPORT_CHUNK_LENGTH = 10; // seconds

const encoders = {
	wav: encodeWav,
	mp3: EncodeMp3Task
};
const modeChannelCount = {
	mono: 1,
	stereo: 2,
	ambisonic: 4
};

/*
May want to add opus
- https://github.com/psirenny/opus-encode
- https://github.com/Rillke/opusenc.js
*/
export default function ExportEngine(project, options = {}) {
	const me = this;

	const sampleRate = options.sampleRate || 44100;
	const format = (options.format || 'mp3').toLowerCase();
	const bitRate = options.bitRate || 128; // in kb, only for mp3
	const bitDepth = options.bitDepth || 16; // in bits, only for wav
	const channelMode = options.channelMode || 'stereo';
	const channelCount = modeChannelCount[channelMode];

	// todo: number of channels other than 2

	const {
		duration
	} = project;

	/*
	todo:
	- abort if no data, tracks or duration
	*/

	let nextTaskId = 1;
	let currentTaskId = 0;
	let exporting = false;
	let progress = 0;
	let context = null;
	let engine = null;
	let encoder = null;
	let abortController = null;

	function log(action) {
		console.log('export', action, {
			sampleRate,
			exportFormat: format,
			bitRate,
			bitDepth,
			duration: Math.round(duration)
		}, action);
	}

	this.start = async () => {
		if (engine) {
			throw new Error('Already rendering audio for export');
		}

		const taskId = nextTaskId++;
		currentTaskId = taskId;
		exporting = true;
		progress = 0;

		log('save');
		abortController = window.AbortController && new AbortController();
		const abortSignal = abortController && abortController.signal;

		// const comments = (state.tracks || []).map(track => {
		// 	const {intensityField} = track;
		// 	const field = state.data.fields[intensityField];
		// 	return field && '- ' + field.name || '';
		// });
		const comments = [];
		comments.push('', `Generated by ${APP_TITLE}`);
		const comment = comments.join('\n');

		const meta = {
			TIT2: 'temporary title',
			TENC: APP_TITLE,
			ISFT: APP_TITLE,
			COMM: {
				description: 'Comment',
				text: comment
			}/*,
			APIC: {
				type: 3,
				data: await fetchIcon(),
				description: APP_TITLE,
				useUnicodeEncoding: false
			}*/
		};

		const Encoder = encoders[format];
		if (!Encoder) {
			throw new Error('Unsupported audio export format: ' + format);
		}

		encoder = new Encoder(meta, {
			channels: channelCount,
			bitRate,
			sampleRate
		}, p => {
			progress = Math.max(progress, p / duration);
			me.emit('progress', progress);
		}, abortSignal);

		encoder.start();

		const numChunks = Math.ceil(duration / EXPORT_CHUNK_LENGTH);
		for (let chunkIndex = 0; chunkIndex < numChunks; chunkIndex++) {
			const chunkStartTime = chunkIndex * EXPORT_CHUNK_LENGTH;
			const chunkEndTime = Math.min(duration, chunkStartTime + EXPORT_CHUNK_LENGTH);
			const chunkDuration = chunkEndTime - chunkStartTime;

			context = new OfflineAudioContext({
				numberOfChannels: channelCount,
				length: sampleRate * chunkDuration,
				sampleRate
			});

			const { destination } = context;
			engine = new AudioEngine({
				destination,
				channelMode
			});
			engine.setProject(project);
			engine.currentTime = chunkStartTime;
			engine.maxDuration = chunkStartTime + chunkDuration;

			const playPromise = engine.play();

			await playPromise;

			// debugger;
			const savedBuffer = await context.startRendering();
			console.log('done rendering chunk export', chunkIndex, {savedBuffer});
			encoder.write(savedBuffer);

			if (!engine) {
				// aborted
				return null;
			}

			engine.destroy();

			if (currentTaskId !== taskId) {
				// aborted and started new task
				return null;
			}
		}


		if (currentTaskId !== taskId) {
			// aborted and started new task
			return null;
		}
		engine = null;
		abortController = null;

		const encodedBlob = await encoder.close();

		log('complete');

		// todo: allow specifying filename?
		exporting = false;
		progress = 1;
		this.emit('finish');

		return encodedBlob;
	};

	this.abort = () => {
		if (engine) {
			engine.destroy();
			engine = null;
		}

		if (abortController) {
			abortController.abort();
			abortController = null;
		}

		if (encoder) {
			encoder.abort();
			encoder = null;
		}

		const aborted = !!exporting;
		currentTaskId = 0;
		exporting = false;
		if (aborted) {
			log('abort');
			this.emit('abort');
		}
	};

	this.destroy = () => {
		this.abort();
		allOff(this);
	};

	eventEmitter(this);

	Object.defineProperties(this, {
		processing: {
			get: () => !!engine
		},
		progress: {
			get: () => progress
		}
	});
}
